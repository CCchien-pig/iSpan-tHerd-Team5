@* 編輯器主 Partial View (_BrandLayoutEditorPartial.cshtml) *@
@model tHerdBackend.SUP.Rcl.Areas.SUP.ViewModels.BrandLayoutEditViewModel

@using System.Text.Json;
@using Microsoft.AspNetCore.Antiforgery

@inject IAntiforgery Antiforgery

@* 引入必要的 URL 輔助函式 *@
@{
    // 修正 AntiForgery Token 獲取方式
    var antiForgeryToken = Antiforgery.GetAndStoreTokens(Context);
    var requestToken = antiForgeryToken.RequestToken;
    var headerName = antiForgeryToken.HeaderName;

    // 將 C# Model 序列化為 JSON 字串，傳給 Vue
    var initialBlocksJson = JsonSerializer.Serialize(Model.LayoutBlocks, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });

    // 【新增】安全地獲取當前版本的版本號，用於編輯時顯示
    var initialVersion = Model.LayoutVersion ?? string.Empty;
}

<div id="brand-layout-editor-app">
    @* <h2>編輯品牌版面: @Model.BrandName</h2> *@

    @* 新增區塊按鈕 *@
    <div id="component-palette" class="mb-3">
        <button @@click="addBlock('Banner')" class="btn btn-sm btn-outline-primary me-2">新增 Banner</button>
        <button @@click="addBlock('Accordion')" class="btn btn-sm btn-outline-info me-2">新增 Accordion</button>
        <button @@click="addBlock('Article')" class="btn btn-sm btn-outline-warning me-2">新增 Article</button>
        @* TODO: 加入 FeaturedProducts 和 Video 區塊按鈕 *@
    </div>

    @* 【新增版號輸入框】綁定 v-model="layoutVersion" *@
    <div class="input-group w-50 mb-3">
        <span class="input-group-text">版號 (必填)</span>
        <input type="text" class="form-control"
               v-model="layoutVersion"
               placeholder="例如：v1.1 或 聖誕促銷版"
               required>
    </div>

    <div id="layout-blocks-container">
        <div v-for="(block, index) in blocks" :key="block.id" class="draggable-block card mb-2">

            @* 區塊header *@
            <div class="card-header block-header" @@click="toggleEdit(block.id)">
                <i class="fa-solid fa-grip-vertical me-2"></i>
                <strong class="me-2">
                    @* 【修正】顯示 #{{ index + 1 }} 來表示順序 *@
                    #{{ index + 1 }} - {{ block.type }} 區塊
                    <span v-if="block.props.title">- {{ block.props.title }}</span>
                </strong>
                @* 唯一識別碼ID *@
                @* <span class="badge bg-secondary">{{ block.id }}</span> *@
                
                @* 動態切換顯示向上/向下箭頭 *@
                <span class="float-end">
                    <svg v-if="editingId === block.id"
                         class="svg-inline--fa fa-chevron-up"
                         aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-up" width="20" height="20" viewBox="0 0 448 512">
                        <path fill="currentColor"
                              d="M224 160c-8.188 0-16.38 3.125-22.62 9.375l-192 192c-12.5 12.5-12.5 32.75 0 45.25s32.75 12.5 45.25 0L224 233.4l169.4 173.2c12.5 12.5 32.75 12.5 45.25 0s12.5-32.75 0-45.25l-192-192C240.4 163.1 232.2 160 224 160z" />
                    </svg>
                    <svg v-else
                         class="svg-inline--fa fa-chevron-down"
                         aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-down" width="20" height="20" viewBox="0 0 448 512">
                        <path fill="currentColor"
                              d="M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z" />
                    </svg>
                </span>
                @* <span>{{ editingId === block.id ? "⬆️" : "⬇️" }}</span> *@
            </div>

            @* 編輯區塊 *@
            <div v-if="editingId === block.id" class="card-body">
                
                @* ================= Banner 區塊編輯 ================= *@
                <template v-if="block.type === 'Banner'">
                    <h5>Banner 區塊編輯</h5>

                    @* --- 圖片上傳區 (結構統一) --- *@
                    <div class="border p-3 rounded mb-3">
                        <h6 class="mb-3">Banner 圖片</h6>
                        <div class="row">
                            <div class="col-md-6 mb-3"><label class="form-label">圖片替代文字 (AltText 必填)</label><input type="text" class="form-control" v-model="block.props.altText"></div>
                            <div class="col-md-6 mb-3"><label class="form-label">圖片說明 (Caption 必填)</label><input type="text" class="form-control" v-model="block.props.caption"></div>
                        </div>                    
                        <div class="mb-3">
                            <label class="form-label">Banner 圖片點擊後的跳轉連結 (可選)</label>
                        <input type="url" class="form-control" v-model="block.props.linkUrl" placeholder="/category/product-slug"></div>

                        <div v-if="block.props.fileUrl || pendingFileUrl" class="text-center mb-3"><img :src="block.props.fileUrl || pendingFileUrl" style="max-width: 100%; max-height: 200px;" alt="預覽" /><p v-if="pendingFileUrl" class="text-muted small mt-1">本地暫存預覽</p><div class="mt-2"><button class="btn btn-sm btn-outline-danger" @@click="removeBlockImage(block)">移除圖片</button></div></div>
                        <div v-if="!block.props.fileUrl && !pendingFileUrl">
                            <div class="mb-3"><label class="form-label">選擇本地圖片</label><input type="file" class="form-control" @@change="handleImageUpload($event, block)" accept="image/*"></div>
                            <div class="text-center my-2 fw-bold">或</div>
                            <div class="mb-3"><label class="form-label">貼上圖片 URL</label><div class="input-group"><input type="text" class="form-control" v-model="block.props.fileUrl" placeholder="貼上 URL 後點擊右側按鈕"><button class="btn btn-outline-primary" type="button" @@click="confirmUploadByUrl(block)">從 URL 上傳</button></div></div>
                        </div>
                        <div class="mt-3 text-center"><button v-if="pendingUpload && block.id === editingId" class="btn btn-success" @@click="confirmUploadAndInsert(block)"><i class="fa-solid fa-cloud-upload-alt"></i> {{ block.props.fileUrl ? '確認上傳並替換' : '確認上傳' }}</button></div>
                    </div>

                    <div class="form-check form-switch mb-2"><input class="form-check-input" type="checkbox" role="switch" v-model="block.props.imageIsActive"><label class="form-check-label">啟用此 Banner 圖片</label></div>
                </template>

                @* ================= Accordion 區塊編輯 ================= *@
                <template v-if="block.type === 'Accordion'">
                    <h5>摺疊區塊編輯</h5>
                    @* ... (標題和內容和啟用 Switch) ... *@
                    <div class="mb-3"><label>摺疊標題：</label><input type="text" class="form-control" v-model="block.props.contentTitle"></div>
                    <div class="mb-3"><label class="form-label">摺疊內容：</label><textarea class="form-control" rows="5" v-model="block.props.content"></textarea></div>
                    <div class="form-check form-switch mb-3" style="margin-left: 5px;">
                        <input class="form-check-input" type="checkbox" v-model="block.props.isActive"><label class="form-check-label">啟用此摺疊內容</label>
                    </div>

                    @* 【核心修正點】加入展開/收合按鈕 *@
                    <div class="d-grid gap-2">
                        <button class="btn btn-outline-secondary btn-sm mb-2"
                                type="button"
                                @@click="block.props.isImageUploaderOpen = !block.props.isImageUploaderOpen">
                            <i :class="['fa-solid', block.props.isImageUploaderOpen ? 'fa-chevron-up' : 'fa-chevron-down']"></i>
                            {{ block.props.isImageUploaderOpen ? '收合圖片上傳區' : '展開圖片上傳區' }}
                        </button>
                    </div>

                    @* --- 圖片上傳區 (結構統一) --- *@
                    <div v-if="block.props.isImageUploaderOpen" class="border p-3 rounded mt-3">
                        <h6 class="mb-3">摺疊內容圖片 (可選)</h6>
                        <div v-if="block.props.fileUrl || pendingFileUrl" class="text-center mb-3"><img :src="block.props.fileUrl || pendingFileUrl" style="max-width: 100%; max-height: 200px;" alt="預覽" /><p v-if="pendingFileUrl" class="text-muted small mt-1">本地暫存預覽</p><div class="mt-2"><button class="btn btn-sm btn-outline-danger" @@click="removeBlockImage(block)">移除圖片</button></div></div>
                        <div v-if="!block.props.fileUrl && !pendingFileUrl">
                            <div class="row">
                                <div class="col-md-6 mb-3"><label class="form-label">圖片替代文字 (必填)</label><input type="text" class="form-control" v-model="block.props.imageAltText"></div>
                                <div class="col-md-6 mb-3"><label class="form-label">圖片說明 (Caption 必填)</label><input type="text" class="form-control" v-model="block.props.imageCaption"></div>
                            </div>
                            <div class="mb-3"><label class="form-label">選擇本地圖片</label><input type="file" class="form-control" @@change="handleImageUpload($event, block)" accept="image/*"></div>
                            <div class="text-center my-2 fw-bold">或</div>
                            <div class="mb-3"><label class="form-label">貼上圖片 URL</label><div class="input-group"><input type="text" class="form-control" v-model="block.props.fileUrl" placeholder="貼上 URL 後點擊右側按鈕"><button class="btn btn-outline-primary" type="button" @@click="confirmUploadByUrl(block)">從 URL 上傳</button></div></div>
                        </div>
                        <div class="mt-3 text-center"><button v-if="pendingUpload && block.id === editingId" class="btn btn-success" @@click="confirmUploadAndInsert(block)"><i class="fa-solid fa-cloud-upload-alt"></i> {{ block.props.fileUrl ? '確認上傳並替換' : '確認上傳' }}</button></div>
                    </div>
                </template>

                @* ================= Article 區塊編輯 ================= *@
                <template v-if="block.type === 'Article'">
                    <h5>品牌文章區塊編輯</h5>
                    @* ... (標題和啟用 Switch) ... *@
                    <div class="mb-3"><label class="form-label">文章標題：</label><input type="text" class="form-control" v-model="block.props.contentTitle"></div>
                    <div class="form-check form-switch mb-3 ms-2">
                        <input class="form-check-input" type="checkbox" v-model="block.props.isActive">
                        <label class="form-check-label">啟用此文章內容</label>
                    </div>

                    @* 【核心修正點】加入展開/收合按鈕 *@
                    <div class="d-grid gap-2">
                        <button class="btn btn-outline-secondary btn-sm mb-3"
                                type="button"
                                @@click="block.props.isImageUploaderOpen = !block.props.isImageUploaderOpen">
                            <i :class="['fa-solid', block.props.isImageUploaderOpen ? 'fa-chevron-up' : 'fa-chevron-down']"></i>
                            {{ block.props.isImageUploaderOpen ? '收合圖片上傳區' : '展開圖片上傳區' }}
                        </button>
                    </div>

                    @* --- 圖片上傳區 (結構統一) --- *@
                    <div v-if="block.props.isImageUploaderOpen" class="border p-3 rounded mt-3">
                        <h6 class="mb-3">文章主圖</h6>
                        <div v-if="block.props.fileUrl || pendingFileUrl" class="text-center mb-3"><img :src="block.props.fileUrl || pendingFileUrl" style="max-width: 100%; max-height: 200px;" alt="預覽" /><p v-if="pendingFileUrl" class="text-muted small mt-1">本地暫存預覽</p><div class="mt-2"><button class="btn btn-sm btn-outline-primary me-2" @@click="insertImageIntoEditor(block)" :disabled="!block.props.fileUrl">插入至文章內</button><button class="btn btn-sm btn-outline-danger" @@click="removeBlockImage(block)">移除圖片</button></div></div>
                        <div v-if="!block.props.fileUrl && !pendingFileUrl">
                            <div class="row">
                                <div class="col-md-6 mb-3"><label class="form-label">圖片替代文字 (必填)</label><input type="text" class="form-control" v-model="block.props.imageAltText"></div>
                                <div class="col-md-6 mb-3"><label class="form-label">圖片說明 (Caption 必填)</label><input type="text" class="form-control" v-model="block.props.imageCaption"></div>
                            </div>
                            <div class="mb-3"><label class="form-label">選擇本地圖片</label><input type="file" class="form-control" @@change="handleImageUpload($event, block)" accept="image/*"></div>
                            <div class="text-center my-2 fw-bold">或</div>
                            <div class="mb-3"><label class="form-label">貼上圖片 URL</label><div class="input-group"><input type="text" class="form-control" v-model="block.props.fileUrl" placeholder="貼上 URL 後點擊右側按鈕"><button class="btn btn-outline-primary" type="button" @@click="confirmUploadByUrl(block)">從 URL 上傳</button></div></div>
                        </div>
                        <div class="mt-3 text-center"><button v-if="pendingUpload && block.id === editingId" class="btn btn-success" @@click="confirmUploadAndInsert(block)"><i class="fa-solid fa-cloud-upload-alt"></i> {{ block.props.fileUrl ? '確認上傳並替換' : '確認上傳' }}</button></div>
                    </div>

                    @* ... (內容) ... *@
                    <div class="mb-3"><label class="form-label mt-3">文章內容：</label><textarea :id="'editor-' + block.id"></textarea></div>
                </template>
                
                @* 移除區塊按鈕 *@
                <button @@click="removeBlock(block.id)" class="btn btn-sm btn-danger mt-2">移除區塊</button>

            </div>

        </div>

        <p v-if="blocks.length === 0" class="text-muted text-center mt-4">請點擊上方按鈕新增區塊</p>
    </div>

    @* 按鈕區 *@
    <div class="d-flex justify-content-between mt-4">
        <button @@click="goToVersions" class="btn btn-outline-secondary ms-auto me-1">
            <i class="fa-solid fa-arrow-left"></i> 返回
        </button>

        <button @@click="saveLayout" class="btn btn-success me-2" :disabled="isSaving">
            <span v-if="isSaving" class="spinner-border spinner-border-sm me-2"></span>
            儲存版面配置
        </button>
    </div>
</div>

<script>
    // ---------------------------------------------------------------------
    // 【核心修正】使用 IIFE 封裝所有邏輯，避免 const/var 重複宣告錯誤 (SyntaxError)
    // ---------------------------------------------------------------------
    (function () {
        // 在局部作用域中安全地解構賦值
        // 【新增】引入 watch，使用 Vue 3 的 watch 和 nextTick，來監聽編輯狀態的變化，並動態地創建和銷毀 TinyMCE 編輯器。
        const { createApp, ref, onMounted, nextTick, watch } = Vue;

        // 1. Razor 變數 (這些是靜態值，但在 IIFE 內被視為局部變數)
        const csrfToken = '@requestToken';
        const csrfHeaderName = '@headerName';
        const brandId = @Model.BrandId;
        const brandName = '@Model.BrandName';
        const initialLayoutId = '@(Model.LayoutId.HasValue? Model.LayoutId.Value.ToString() : "null")';
        const initialBlocks = @Html.Raw(initialBlocksJson);
        // 獲取後端傳來或空的版本號
        const initialVersion = '@(Model.LayoutVersion ?? "")';
        // 從後端獲取當前所有版本號列表，用於前端驗證
        const existingVersions = @Html.Raw(JsonSerializer.Serialize(Model.AllLayoutVersions ?? new List<string>()));
        // 從 Razor Model 獲取當前啟用 ID
        const currentActiveLayoutId = @(Model.CurrentActiveLayoutId?.ToString() ?? "null");


        // 儲存區塊的預設屬性工廠
        const createProps = (type) => {
            const today = new Date();
            const dateString = `${today.getFullYear()}/${(today.getMonth() + 1).toString().padStart(2, '0')}/${today.getDate().toString().padStart(2, '0')}`;

            switch (type) {
                case 'Banner':
                    return {
                        contentId: 0,
                        fileId: null,
                        fileUrl: '',
                        linkUrl: '',
                        altText: brandName, // 對應 BannerDto.AltText
                        caption: `${brandName}_Banner_${dateString}`, // 對應 BannerDto.Caption
                        imageIsActive: true // 對應 BannerDto.IsActive
                    };
                case 'Accordion':
                    return {
                        contentId: 0,
                        contentTitle: '',
                        content: '',
                        isActive: true, // 內容本身的啟用狀態
                        imgId: null,
                        fileUrl: '', // 用於預覽
                        imageAltText: brandName,
                        imageCaption: `${brandName}_Banner_${dateString}`,
                        imageIsActive: true, // 圖片的啟用狀態
                        isImageUploaderOpen: false // 【新增】預設為摺疊
                    };
                case 'Article': // 品牌文章區塊
                     return {
                        contentId: 0,
                        contentTitle: brandName + '品牌文章', // 對應 [ContentTitle]
                        content: '', // 對應 [Content]
                        isActive: true, // 內容啟用狀態
                        // Article 圖片元數據
                        imgId: null, // 對應 [ImgId]
                        fileUrl: '',
                        imageAltText: brandName,
                        imageCaption: `${brandName}_Article_${dateString}`,
                        imageIsActive: true, // 圖片啟用狀態
                        isImageUploaderOpen: false // 【新增】預設為摺疊
                    };
                default:
                    return {};
            }
        };

        const App = {
            setup() {
                // 核心響應式資料
                const blocks = ref(initialBlocks);
                const editingId = ref(null);
                const isSaving = ref(false);
                const layoutIdState = ref(initialLayoutId);
                const layoutVersion = ref(initialVersion);
                // 【新增 Ref】用於暫存待上傳的 File 物件和本地 URL
                const pendingUpload = ref(null);
                const pendingFileUrl = ref(null);
                // 【新增變數】用於判斷編輯中的版本是否已經啟用
                const isCurrentlyActive = ref(currentActiveLayoutId !== 'null' &&
                                               parseInt(layoutIdState.value) === parseInt(currentActiveLayoutId));

                // 版本號建議值
                if (layoutIdState.value === 'null' && initialVersion === '') {
                    let maxVersion = 0.0;
                    if (existingVersions && existingVersions.length > 0) {
                        existingVersions.forEach(v => {
                            // 確保 v 不是 null 或 undefined
                            if (v) {
                                const match = v.match(/^v(\d+\.\d+)/);
                                if (match) {
                                    const num = parseFloat(match[1]);
                                    if (num > maxVersion) maxVersion = num;
                                }
                            }
                        });
                    }

                    let suggestedVersion;
                    // 【核心修正點】如果沒有找到任何版本，從 v1.0 開始
                    if (maxVersion === 0.0) {
                        suggestedVersion = 'v1.0';
                    } else {
                        // 否則，在最大版本號上 +0.1
                        suggestedVersion = `v${(maxVersion + 0.1).toFixed(1)}`;
                    }
                    layoutVersion.value = suggestedVersion;
                }

                // 初始化 SortableJS
                const initSortable = () => {
                    const el = document.getElementById('layout-blocks-container');
                    if (el) {
                        Sortable.create(el, {
                            animation: 150,
                            handle: '.block-header',
                            onEnd: (evt) => {
                                const { oldIndex, newIndex } = evt;
                                if (oldIndex !== newIndex) {
                                    const movedItem = blocks.value[oldIndex];
                                    blocks.value.splice(oldIndex, 1);
                                    blocks.value.splice(newIndex, 0, movedItem);
                                }
                            }
                        });
                    }
                };

                // 【新增輔助函式】在 JS 中生成一個簡易的唯一 ID
                function generateUniqueId() {
                    return 'xxxxxxxx'.replace(/[x]/g, function(c) {
                        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    });
                }

                // 新增區塊
                const addBlock = (type) => {
                    const newBlock = {
                        id: generateUniqueId(),
                        type: type,
                        props: createProps(type)
                    };
                    blocks.value.push(newBlock);

                    // 【核心修正點】新增後，立即將 editingId 設為新區塊的 ID
                    editingId.value = newBlock.id;

                    // 滾動邏輯
                    nextTick(() => {
                        const container = document.getElementById('layout-blocks-container');
                        if (container) { container.scrollTop = container.scrollHeight; }
                    });
                };

                // 【新增】Switch 狀態變更通知函式
                const handleSwitchChange = (isActive, itemName) => {
                    Swal.fire({
                        toast: true,
                        position: 'center',
                        icon: isActive ? 'success' : 'info',
                        title: `${itemName} 已${isActive ? '啟用' : '停用'}`,
                        showConfirmButton: false,
                        timer: 1500
                    });
                };
                // 【新增】移除區塊圖片
                const removeBlockImage = (block) => {
                    // 1. 清除核心數據
                    block.props.imgId = null;
                    block.props.fileId = null; // 確保 Banner 的 fileId 也被清除
                    block.props.fileUrl = null; 
    
                    // 2. 清除暫存區的數據 (如果用戶還沒上傳就點了移除)
                    pendingUpload.value = null;
                    pendingFileUrl.value = null;

                    // 3. 清除元數據，讓使用者下次上傳時重新輸入
                    block.props.imageAltText = '';
                    block.props.imageCaption = '';

                    // 4. (可選) 提醒使用者移除成功
                    Swal.fire('圖片已移除', '請點擊儲存，以確認變更。', 'info');
                };


                // 移除區塊
                const removeBlock = (id) => {
                    Swal.fire({
                        title: '確定移除此區塊嗎？',
                        icon: 'warning',
                        showCancelButton: true,
                        confirmButtonText: '確定移除'
                    }).then((result) => {
                        if (result.isConfirmed) {
                            blocks.value = blocks.value.filter(b => b.id !== id);
                            if (editingId.value === id) { editingId.value = null; }
                            Swal.fire('已移除', '區塊已從版面中移除，請記得儲存。', 'success');
                        }
                    });
                };

                // 切換編輯面板
                const toggleEdit = (id) => { editingId.value = editingId.value === id ? null : id; };

                // 【新增】前端 Banner 驗證邏輯
                function validateBlocks(blocks) {
                    // 【核心修正點】使用 for 迴圈來獲取索引
                    for (let i = 0; i < blocks.length; i++) {
                        const block = blocks[i];
                        if (block.type === 'Banner') {
                            // 【修正】只要 fileUrl 有值就通過
                            if (!block.props.fileUrl || block.props.fileUrl.trim() === '') {
                                // 使用索引 i + 1 來顯示排序
                                return `[#${i + 1} - Banner 區塊] 必須提供圖片 URL。`;
                            }
                        }
                        // TODO: 可以在這裡加入 Accordion 的內容驗證等
                    }
                    return null; // 驗證通過
                }

                // 【新增】統一的圖片元數據驗證函式
                function validateImageMeta(block) {
                    let alt, cap;
                    // 根據區塊類型，獲取正確的屬性名稱
                    if (block.type === 'Banner') {
                        alt = block.props.altText;
                        cap = block.props.caption;
                    } else { // Accordion, Article
                        alt = block.props.imageAltText;
                        cap = block.props.imageCaption;
                    }

                    if (!alt || alt.trim() === '') {
                        return '請先輸入圖片的替代文字 (AltText)。';
                    }
                    if (!cap || cap.trim() === '') {
                        return '請先輸入圖片說明 (Caption)。';
                    }
                    return null; // 驗證通過
                }

                // 儲存版面配置
                const saveLayout = async () => {
                    if (!layoutVersion.value) {
                        Swal.fire('錯誤', '請輸入版型版本號。', 'warning');
                        return;
                    }

                    const validationError = validateBlocks(blocks.value);
                    if (validationError) {
                        Swal.fire('驗證失敗', validationError, 'warning');
                        return;
                    }

                    isSaving.value = true;
                    let savedLayoutId = null;

                    try {
                        // ==========================================================
                        // 【核心修正點】數據淨化 (Data Sanitization)
                        // ==========================================================
                        const cleanBlocks = blocks.value.map(block => ({
                            id: block.id,
                            type: block.type,
                            props: {
                                    // 通用欄位
                                contentId: block.props.contentId || 0,
                                isActive: block.props.isActive,

                                    // Accordion & Article 欄位
                                contentTitle: block.props.contentTitle,
                                content: block.props.content,

                                    // Banner 欄位
                                altText: block.props.altText,
                                caption: block.props.caption,
                                fileId: block.props.fileId,
                                fileUrl: block.props.fileUrl,
                                linkUrl: block.props.linkUrl,

                                    // 其他您需要的欄位...
                                imgId: block.props.imgId
                            }
                        }));

                        console.log("淨化後準備發送的資料:", cleanBlocks);

                        const currentLayoutId = layoutIdState.value;
                        const payload = {
                            BrandId: brandId,
                            ActiveLayoutId: currentLayoutId !== 'null' ? parseInt(currentLayoutId) : null,
                            LayoutVersion: layoutVersion.value,
                            // ✅ 不要 stringify
                            FullLayoutJson: cleanBlocks,
                        };

                        const url = '/SUP/Brands/SaveLayout';
                        const headers = {
                            'Content-Type': 'application/json',
                            [csrfHeaderName]: csrfToken
                        };

                        const response = await fetch(url, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify(payload)
                        });

                        // 強化錯誤處理:檢查回應狀態碼是否為 2xx (成功)
                        if (!response.ok) {
                            let errorHtml = `API 錯誤: ${response.status} (${response.statusText})`;

                            // 1. 先將回應主體作為文字讀取出來
                            const errorText = await response.text();

                            try {
                                // 2. 嘗試將文字解析為 JSON
                                const errorJson = JSON.parse(errorText);

                                if (errorJson.errors) {
                                    errorHtml = '<ul>';
                                    // 將所有驗證錯誤訊息組合成一個列表
                                    for (const key in errorJson.errors) {
                                        errorJson.errors[key].forEach(msg => {
                                            errorHtml += `<li>${msg}</li>`;
                                        });
                                    }
                                    errorHtml += '</ul>';
                                } else if (errorJson.message) {
                                    errorHtml = errorJson.message;
                                }
                            } catch (e) {
                                // 如果解析 JSON 失敗，表示後端可能回傳了 HTML 錯誤頁面
                                // 直接顯示原始的文字內容
                                errorHtml = `<pre style="text-align:left; background-color:#f8d7da; padding:10px; border-radius:5px;">${errorText}</pre>`;
                            }

                            Swal.fire({
                                title: '儲存失敗',
                                html: errorHtml,
                                icon: 'error'
                            });

                            return; // 中止執行
                        }
                            // 如果程式碼執行到這裡，表示回應是成功的
                        const resJson = await response.json();

                        if (response.ok && resJson.success) {
                            savedLayoutId = resJson.layoutId;
                            layoutIdState.value = savedLayoutId.toString();

                            // --- 流程判斷區 ---
                            if (isCurrentlyActive.value) {
                                // 情況 A: 正在編輯啟用中的版本
                                Swal.fire({
                                    title: '儲存成功！',
                                    text: "此版本已是當前啟用狀態，變更已生效。",
                                    icon: 'success',
                                    showConfirmButton: true,
                                    confirmButtonText: '返回列表'
                                }).then(() => {
                                    if (typeof reloadVersionIndex === 'function') {
                                        reloadVersionIndex(brandId);
                                    }
                                });

                            } else {
                                // 情況 B: 編輯/新增了一個非啟用中的版本，需要詢問是否啟用
                                const result = await Swal.fire({
                                    title: '儲存成功！',
                                    text: "是否要立即啟用此版本？",
                                    icon: 'success',
                                    showCancelButton: true,
                                    confirmButtonText: '立即啟用',
                                    cancelButtonText: '稍後再說'
                                });

                            if (result.isConfirmed) {
                                // 使用者選擇啟用 → 執行 AJAX
                                await new Promise((resolve) => {
                                    $.ajax({
                                        url: `/SUP/Brands/ActivateLayout/${savedLayoutId}`,
                                        type: 'POST',
                                        headers: { [csrfHeaderName]: csrfToken },
                                        success: function (data) {
                                            console.log("[DEBUG] 啟用成功，後端回傳:", data);
                                            if (data.success) {
                                                Swal.fire('啟用成功', data.message, 'success').then(() => {
                                                    const indexUrl = `/SUP/Brands/GetLayoutVersions/__BRANDID__`
                                                        .replace('__BRANDID__', brandId);
                                                    loadLayoutEditor(indexUrl, `版本管理：${brandName}`);
                                                });
                                            } else {
                                                console.error("[DEBUG] 啟用失敗:", data.message);
                                                Swal.fire('啟用失敗', data.message, 'error');
                                            }
                                        },
                                        error: function (jqXHR) {
                                            Swal.fire('伺服器錯誤', '啟用操作失敗。', 'error');
                                        },
                                        complete: () => {
                                            if (typeof reloadVersionIndex === 'function') reloadVersionIndex(brandId);
                                            resolve();
                                        }
                                    });
                                });
                            } else {
                                // 使用者選擇不啟用 → 回列表
                                if (typeof reloadVersionIndex === 'function') {
                                    reloadVersionIndex(brandId);
                                    }
                                }
                            }
                        } else {
                            Swal.fire('操作失敗', resJson.message || '後端返回了 success: false', 'error');
                        }
                    } catch (error) {
                        console.error('Save failed:', error);
                        Swal.fire('網路錯誤', '無法連線到伺服器或發生未預期錯誤。', 'error');
                    } finally {
                        isSaving.value = false;
                    }
                };

                // 允許的 MIME 類型清單
                const ALLOWED_IMAGE_MIMES = [
                    'image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/avif', 'image/tiff',
                    'image/bmp', 'image/heic', 'image/heif', 'image/svg+xml' // 這裡列出了常見的 MIME 類型
                ];

                // 【修正】本地上傳：只做驗證和本地預覽
                const handleImageUpload = (event, block) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    // 1. 【修正】只保留檔案類型驗證
                    if (!ALLOWED_IMAGE_MIMES.includes(file.type)) {
                        Swal.fire('錯誤', `不支援的檔案類型：${file.type}。請選擇圖片檔案。`, 'error');
                        event.target.value = '';
                        return;
                    }

                    // 2. 移除 AltText 和 Caption 的驗證

                    // 3. 處理本地預覽 (保持不變)
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        pendingFileUrl.value = e.target.result;
                        pendingUpload.value = file;
                    };
                    reader.readAsDataURL(file);
                };

                // 【新增】處理最終上傳的函式
                const confirmUploadAndInsert = (block) => {
                    const file = pendingUpload.value;
                    if (!file) {
                         Swal.fire('錯誤', '請先選擇圖片檔案。', 'warning');
                         return;
                    }

                    // 【核心修正點】在這裡執行最終的元數據驗證
                    const validationError = validateImageMeta(block);
                    if (validationError) {
                        Swal.fire('驗證失敗', validationError, 'warning');
                        return;
                    }

                    const formData = new FormData();
                    formData.append('file', file, file.name);
                    formData.append('blockType', block.type);
                    // 將 Vue props 中的元數據附加到 FormData
                    formData.append('altText', block.props.imageAltText);
                    formData.append('caption', block.props.imageCaption);
                    formData.append('isActive', true); // 或者綁定到 v-model
                    
                    // 找到 input[type="file"] 元素
                    const fileInput = document.querySelector(`div[v-if="block.type === 'Article'"] input[type="file"]`);

                    // 顯示上傳中的提示
                    Swal.fire({ title: '上傳中...', allowOutsideClick: false, didOpen: () => { Swal.showLoading() } });

                    // 執行 AJAX 上傳
                    $.ajax({
                        url: '/api/assets/upload-content-image', // 使用同一個 API 端點
                        type: 'POST',
                        data: formData,
                        processData: false,
                        contentType: false,
                        headers: { [csrfHeaderName]: csrfToken },
                        success: function(res) {
                            if (res.location && res.fileId) {
                                // 更新 Vue 的數據模型
                                block.props.imgId = res.fileId;
                                block.props.fileUrl = res.location; // 用於顯示預覽
                                
                                // 清理暫存狀態
                                pendingUpload.value = null;
                                pendingFileUrl.value = null;

                                // 【核心修正點】清除檔案輸入框的值
                                if (fileInput) {
                                    fileInput.value = '';
                                }

                                // 插入編輯器
                                insertImageIntoEditor(block);
                                
                                Swal.fire('成功', '圖片已成功上傳並暫存！', 'success');
                            } else {
                                Swal.fire('上傳失敗', '後端未返回有效的圖片資訊。', 'error');
                            }
                        },
                        error: function(xhr) {
                            // 確保錯誤時也清空 input file 的值
                            if (fileInput) {
                                fileInput.value = '';
                            }
                            Swal.fire('上傳失敗', `伺服器錯誤: ${xhr.statusText}`, 'error');
                        }
                    });
                };

                // 【新增】從 URL 上傳的函式
                const confirmUploadByUrl = (block) => {
                    // 【核心修正點】在這裡執行最終的元數據驗證
                    const validationError = validateImageMeta(block);
                    if (validationError) {
                        Swal.fire('驗證失敗', validationError, 'warning');
                        return;
                    }

                    Swal.fire({ title: '處理中...', text: '正在從遠端下載並上傳圖片...', allowOutsideClick: false, didOpen: () => { Swal.showLoading() } });

                    // 準備發送到後端的 payload
                    const payload = {
                        imageUrl: block.props.fileUrl,
                        blockType: block.type,
                        altText: block.props.imageAltText,
                        caption: block.props.imageCaption,
                        isActive: block.props.imageIsActive
                    };

                    // 3. 呼叫後端的 upload-by-url API
                    $.ajax({
                        url: '/api/assets/upload-by-url',
                        type: 'POST',
                        contentType: 'application/json', // 必須是 application/json
                        data: JSON.stringify(payload),   // 必須序列化為 JSON 字串
                        headers: { [csrfHeaderName]: csrfToken },
                        success: function(res) {
                            if (res.location && res.fileId) {
                                // 更新 Vue 數據模型 (與本地上傳成功後的回調相同)
                                if (block.type === 'Banner') {
                                    block.props.fileId = res.fileId;
                                } else { // Accordion, Article
                                    block.props.imgId = res.fileId;
                                }
                                block.props.fileUrl = res.location;
                                Swal.fire('成功', '圖片已從 URL 成功上傳！', 'success');
                            } else {
                                Swal.fire('上傳失敗', '後端未返回有效的圖片資訊。', 'error');
                            }
                        },
                        error: function(xhr) {
                            // 嘗試解析後端回傳的 JSON 錯誤訊息
                            let errorMsg = `伺服器錯誤: ${xhr.statusText}`;
                            if (xhr.responseJSON && xhr.responseJSON.error && xhr.responseJSON.error.message) {
                                errorMsg = xhr.responseJSON.error.message;
                            }
                            Swal.fire('上傳失敗', errorMsg, 'error');
                        }
                    });
                };

                // 【新增】將圖片插入到 TinyMCE 編輯器
                const insertImageIntoEditor = (block) => {
                    const editor = tinymce.get('editor-' + block.id);
                    if (editor && block.props.fileUrl) {
                        const defaultWidth = 600;

                        const imgHtml = `<img src="${block.props.fileUrl}"
                                                alt="${block.props.imageAltText}"
                                                width="${defaultWidth}"
                                                style="max-width: 100%; height: auto;" />`; // 設置最大寬度 100%

                        editor.execCommand('mceInsertContent', false, imgHtml);
                    }
                };


                // 返回版本管理
                const goToVersions = () => {
                    const brandId = @Model.BrandId;
                    const brandName = '@Model.BrandName'; // 假設已注入

                    // 呼叫主頁面的 loadLayoutEditor 重新載入版本列表
                    if (typeof loadLayoutEditor === 'function') {
                        const indexUrl = '@Url.Action("GetLayoutVersions", "Brands", new { area = "SUP", id = "__ID__" })'.replace('__ID__', brandId);
                        loadLayoutEditor(indexUrl, `版本管理：${brandName}`);
                    } else {
                        // 如果 loadLayoutEditor 不在全局作用域，則關閉 Modal
                        $('#brandLayoutModal').modal('hide');
                    }
                };

                // 【核心修正版】TinyMCE 初始化於 watch(editingId)
                watch(editingId, (newId, oldId) => {
                  // 1️⃣ 銷毀舊編輯器
                  if (oldId) {
                    const oldEditor = tinymce.get('editor-' + oldId);
                    if (oldEditor) oldEditor.destroy();
                  }

                  // 2️⃣ 建立新編輯器
                  if (newId) {
                    const currentBlock = blocks.value.find(b => b.id === newId);
                    if (currentBlock && currentBlock.type === 'Article') {
                      nextTick(() => {
                        tinymce.init({
                          selector: '#editor-' + newId,
                          plugins: 'lists link image table code help wordcount',
                          toolbar:
                            'undo redo | blocks | bold italic | alignleft aligncenter alignright | bullist numlist outdent indent | link | code | help',
                          menubar: false,
                          branding: false,
                          height: 500,

                          // 🖼️ 圖片上傳設定
                          image_title: true,
                          automatic_uploads: true,
                          file_picker_types: 'image',
                          image_dimensions: true,
                          image_advtab: true,

                          setup: function (editor) {
                            editor.on('init', function () {
                                editor.setContent(currentBlock.props.content || '');
                            });

                            // ✅ 關鍵：TinyMCE dialog 打開時暫時移除 Bootstrap 的焦點陷阱
                            editor.on('OpenWindow', function () {
                              console.log('🟢 TinyMCE 對話框開啟，暫停 Bootstrap 焦點鎖');
                              const modal = document.querySelector('#brandLayoutModal');

                              if (modal && bootstrap && bootstrap.Modal && bootstrap.Modal.getInstance(modal)) {
                                const instance = bootstrap.Modal.getInstance(modal);
                                // 暫時停用Bootstrap Modal 的焦點攔截
                                instance._focustrap?.deactivate();
                              }

                              // 延遲清除 TinyMCE 自身 tabindex
                              setTimeout(() => {
                                document.querySelectorAll('.tox-dialog, .tox-dialog-wrap, .tox-tinymce-aux [tabindex="-1"]').forEach(el => {
                                  el.removeAttribute('tabindex');
                                });
                              }, 50); //延遲 50ms 清除 tabindex 可確保 TinyMCE 對話框已完全渲染
                            });

                            // ✅ 對話框關閉時恢復焦點捕獲
                            editor.on('CloseWindow', function () {
                              console.log('🔵 TinyMCE 對話框關閉，恢復 Bootstrap 焦點鎖');
                              const modal = document.querySelector('#brandLayoutModal');
                              if (modal && bootstrap && bootstrap.Modal && bootstrap.Modal.getInstance(modal)) {
                                const instance = bootstrap.Modal.getInstance(modal);
                                //TinyMCE 對話框關閉後，恢復原本的焦點陷阱
                                instance._focustrap?.activate();
                              }
                            });

                            editor.on('input change', function () {
                                currentBlock.props.content = editor.getContent();
                            });
                          },
                        });
                      });
                    }
                  }
                });


                onMounted(() => {
                    initSortable();
                });

                return {
                    blocks,
                    editingId,
                    isSaving,
                    addBlock,
                    removeBlock,
                    toggleEdit,
                    layoutVersion,
                    goToVersions, 
                    isCurrentlyActive,
                    saveLayout,
                    pendingUpload,
                    pendingFileUrl, // 回傳給模板用於預覽
                    confirmUploadAndInsert,
                    handleImageUpload,
                    insertImageIntoEditor,
                    removeBlockImage,
                    handleSwitchChange,
                    confirmUploadByUrl
                };
            }
        };

        // 【關鍵】每次載入新的 HTML 內容時，重新掛載 Vue 應用程式
        // 確保 DOM 元素 #brand-layout-editor-app 存在時才掛載
        if (document.getElementById('brand-layout-editor-app')) {
             createApp(App).mount('#brand-layout-editor-app');
        } else {
            console.error("Vue 掛載失敗：找不到 DOM 元素 #brand-layout-editor-app");
        }
    })(); // IIFE 結束
</script>